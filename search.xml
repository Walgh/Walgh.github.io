<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP-IP协议簇</title>
      <link href="2020/11/19/tcp-ip-xie-yi-cu/"/>
      <url>2020/11/19/tcp-ip-xie-yi-cu/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-IP协议簇"><a href="#TCP-IP协议簇" class="headerlink" title="TCP-IP协议簇"></a>TCP-IP协议簇</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>第一次：sender-&gt;reciever  发送SYN=1<br>第二次：reciever-&gt;sender  发送SYN=1 ACK=1<br>第三次：sender-&gt;reciever  发送ACK=1<br>ack = seq+1   小写ack确认序号</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>reciever收到3个包将回传3个确认，sender知晓当前3个窗口空闲，继续发送3个包，避免网络拥堵</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>第一次：sender-&gt;reciever  发送FIN=1<br>第二次：reciever-&gt;sender  发送ACK=1<br>第三次：reciever-&gt;sender  发送FIN=1  因为此时sender虽然发起断开请求，但reciever不一定接收完数据，所以需要等待数据确认后由reciever向sender发送FIN=1<br>第四次：sender-&gt;reciever  发送ACK=1</p><h2 id="端口号类型"><a href="#端口号类型" class="headerlink" title="端口号类型"></a>端口号类型</h2><h2 id="TCP数据段重组"><a href="#TCP数据段重组" class="headerlink" title="TCP数据段重组"></a>TCP数据段重组</h2><p>使用序列号</p><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>有IPv4(32bit)和IPv6(128bit)<br>TTL值：生命周期，每经过一次路由-1，当TTL为0时丢弃该数据包</p><h2 id="常见IP协议"><a href="#常见IP协议" class="headerlink" title="常见IP协议"></a>常见IP协议</h2><p>ICMP(网际控制报文协议)：检测网络层的连通性，发送echo request，目标收到后，发送echo reply 常用命令有ping、traceroute<br>ARP(地址解析协议)：通过广播查询IP对应的MAC，有代理ARP和反向ARP</p>]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCNA </tag>
            
            <tag> 网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础</title>
      <link href="2020/11/19/wang-luo-ji-chu/"/>
      <url>2020/11/19/wang-luo-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h1><h2 id="什么是网络"><a href="#什么是网络" class="headerlink" title="什么是网络"></a>什么是网络</h2><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><pre><code>1. Hub(集线器)优点：便宜缺点：共享型，无法满足多人同时访问2. 交换机优点：可实现多用户同时访问，支持全双工缺点：共享型，无法满足多人同时访问作用：终端用户设备的接入\基本的安全功能\广播域的隔离（VLAN）     所有的接口在同一个广播域3. 路由器每一个接口是一个独立的广播域优点：可搭建大型网络、安全性高缺点：接口太少、价格太贵作用：路由协议支持\路径选择\数据转发\广域网接入4. TIPS传输类型：单工(始终只能完成一个方向的数据传输)半双工(同一时间只能完成一个方向的数据传输)全双工(同一时间可以完成两个方向的数据传输)数据类型：广播报文(单IP到所有IP)单播报文(单IP到单IP)组播报文(单IP到多IP，类似朋友圈的部分可见）</code></pre><h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><pre><code>从下至上分别是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</code></pre><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><pre><code>为应用软件提供接口，使应用程序能够使用网络服务http(80)https(443)dns(53)ftp(20/21)smtp(25)pop3(110)telnet(23)上述数字代表其端口号</code></pre><h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><pre><code>数据的解码和编码 加密和解密 压缩和解压缩</code></pre><h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><pre><code>负责建立、管理和终止表示层实体之间的会话连接</code></pre><h2 id="传输层-主要为TCP-UDP"><a href="#传输层-主要为TCP-UDP" class="headerlink" title="传输层(主要为TCP/UDP)"></a>传输层(主要为TCP/UDP)</h2><pre><code>负责建立端到端的连接，保证报文在端到端之间的传输</code></pre><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><pre><code>为网络设备提供逻辑地址进行路由选择、维护路由表负责将分组数据从源端传输到目的端代表：路由器</code></pre><h2 id="数据链路层-MAC"><a href="#数据链路层-MAC" class="headerlink" title="数据链路层(MAC)"></a>数据链路层(MAC)</h2><pre><code>在不可靠的物理链路上，提供可靠的数据传输服务，把帧从一跳(结点)移动到另一帧（结点）组帧、物理编址、流量控制、差错控制、接入控制代表：交换机</code></pre><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><pre><code>负责把逐个的比特从一跳(结点)移动到另一跳(结点)代表：集线器</code></pre><h1 id="DoD-TCP-IP-模型"><a href="#DoD-TCP-IP-模型" class="headerlink" title="DoD(TCP/IP)模型"></a>DoD(TCP/IP)模型</h1><pre><code>从下至上分别是网络访问层、Internet层、传输层、应用层</code></pre><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><pre><code>广播域的进出口</code></pre>]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCNA </tag>
            
            <tag> 网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP子网规划</title>
      <link href="2020/11/19/ip-zi-wang-gui-hua/"/>
      <url>2020/11/19/ip-zi-wang-gui-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="IP子网规划"><a href="#IP子网规划" class="headerlink" title="IP子网规划"></a>IP子网规划</h1><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>网络层概念<br>主机唯一的标志，保证主机间正常通信<br>IPv4地址由32bit组成</p><h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p>IP地址共分A|B|C|D|E5个类别</p><img src="/2020/11/19/ip-zi-wang-gui-hua/IP地址分类.PNG" alt="IP地址分类" style="zoom:80%;"><h3 id="特殊IPv4地址"><a href="#特殊IPv4地址" class="headerlink" title="特殊IPv4地址"></a>特殊IPv4地址</h3><p>网络地址和广播地址<br>默认路由：0.0.0.0<br>环回地址：127.0.0.0/8 用于测试<br>链路本地地址：169.254.0.0/16 Windows<br>TEST-NET地址：192.0.2.0/24 保留地址</p><h2 id="IP地址的组成"><a href="#IP地址的组成" class="headerlink" title="IP地址的组成"></a>IP地址的组成</h2><p>IP地址由两部分组成<br> 网络部分（NETWORK）<br> 主机部分（HOST）</p><img src="/2020/11/19/ip-zi-wang-gui-hua/IP地址组成.PNG" alt="IP地址组成" style="zoom:80%;"><img src="/2020/11/19/ip-zi-wang-gui-hua/IP地址分类2.PNG" alt="IP地址第二分类" style="zoom:80%;"><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>用来确定IP的网络地址<br>32个二进制位<br>IP地址中的网络部分用1表示，主机部分用0表示<br>IP地址和子网掩码作逻辑“与”运算得到网络地址</p><h2 id="IPv4网络中的地址类型"><a href="#IPv4网络中的地址类型" class="headerlink" title="IPv4网络中的地址类型"></a>IPv4网络中的地址类型</h2><h3 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h3><p>指代网络的地址，在网络的IPv4地址范围内，最小地址保留为网络地址。此地址的主机部分的每一个主机位为0</p><h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><p>用于向网络中的所有主机发送数据的特殊地址。广播地址使用该网络范围内的最大地址。即主机部分的各比特位全部为1的地址。</p><h3 id="主机地址"><a href="#主机地址" class="headerlink" title="主机地址"></a>主机地址</h3><p>分配给网络中终端设备的地址</p><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>子网划分：将网络划分为适当大小的多个子网</p><h3 id="为什么要划分子网？"><a href="#为什么要划分子网？" class="headerlink" title="为什么要划分子网？"></a>为什么要划分子网？</h3><ol><li>提供灵活的编制</li><li>便于管理</li><li>广播抑制<br>“借用”主机位来“制造”新的“网络”（网络位向主机位借位）</li></ol><h3 id="子网划分原理"><a href="#子网划分原理" class="headerlink" title="子网划分原理"></a>子网划分原理</h3><p>IP地址经过一次子网划分后，被分成3个部分——网络位、子网位和主机位<br>子网数=2^n，其中n为子网部分位数<br>主机数=2^N-2，其中N为主机部分位数</p>]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCNA </tag>
            
            <tag> IP子网规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接库</title>
      <link href="2020/11/17/dong-tai-lian-jie-ku/"/>
      <url>2020/11/17/dong-tai-lian-jie-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="动态链接库"><a href="#动态链接库" class="headerlink" title="动态链接库"></a>动态链接库</h2><h3 id="1-DLL的创建"><a href="#1-DLL的创建" class="headerlink" title="1. DLL的创建"></a>1. DLL的创建</h3><h4 id="1-1-函数的导出"><a href="#1-1-函数的导出" class="headerlink" title="1.1 函数的导出"></a>1.1 函数的导出</h4><p>方法1：在导出函数前面添加<strong>标识符</strong>：</p><pre class=" language-c++"><code class="language-c++">_declspec（dllexport）</code></pre><p>方法2：将上述指令进行<strong>宏定义</strong></p><pre class=" language-c++"><code class="language-c++">#define DLL_API _declspec（dllexport）</code></pre><h4 id="1-2-类的导出"><a href="#1-2-类的导出" class="headerlink" title="1.2 类的导出"></a>1.2 类的导出</h4><p>在类名前加入宏定义 DLL_API</p><pre class=" language-c++"><code class="language-c++">ex:class DLL_API XXCLASS{}</code></pre><p>若只需导出类中的某个函数，则可只在对应函数前加入修饰符、</p><p>调用方法均需要先对类进行实例化，且<strong>导出函数必须是public属性</strong></p><h4 id="1-3-支持MFC的DLL"><a href="#1-3-支持MFC的DLL" class="headerlink" title="1.3 支持MFC的DLL"></a>1.3 支持MFC的DLL</h4><h5 id="1-3-1-动态链接MFC"><a href="#1-3-1-动态链接MFC" class="headerlink" title="1.3.1 动态链接MFC"></a>1.3.1 动态链接MFC</h5><p>发布DLL时需提供MFC动态链接库</p><h5 id="1-3-2-静态链接MFC"><a href="#1-3-2-静态链接MFC" class="headerlink" title="1.3.2 静态链接MFC"></a>1.3.2 静态链接MFC</h5><p>发布时无需提供MFC动态链接库</p><h5 id="1-3-3-MFC扩展DLL"><a href="#1-3-3-MFC扩展DLL" class="headerlink" title="1.3.3 MFC扩展DLL"></a>1.3.3 MFC扩展DLL</h5><p>使用共享的MFC DLL，支持导出MFC类，而两种方式只支持导出自己编写的C++类</p><h3 id="2-DLL的调用"><a href="#2-DLL的调用" class="headerlink" title="2. DLL的调用"></a>2. DLL的调用</h3><h4 id="2-1-隐式加载"><a href="#2-1-隐式加载" class="headerlink" title="2.1 隐式加载"></a>2.1 隐式加载</h4><p><strong>方法1：</strong>使用<strong>extern关键字</strong>对引用函数进行外部声明 </p><p><strong>方法2：</strong>使用标识符——<strong>declspec（dllimport）</strong>对引用函数进行声明</p><p><strong>方法3：</strong>在发布DLL时提供头文件，头文件内包含导出函数、类（<strong>实际应用均应该这样</strong>）</p><pre class=" language-c++"><code class="language-c++">ex:#ifdef DLL_API#else#define DLL_API _declspec(dllimport)#endifDLL_API fun1();DLL_API fun2();...</code></pre><h4 id="2-2-显示加载"><a href="#2-2-显示加载" class="headerlink" title="2.2 显示加载"></a>2.2 显示加载</h4><p>LoadLibary函数</p><p>FreeLibrary函数：释放该DLL</p><h4 id="2-3-隐式和显示的区别"><a href="#2-3-隐式和显示的区别" class="headerlink" title="2.3 隐式和显示的区别"></a>2.3 隐式和显示的区别</h4><p>显示加载时在程序调用时才进行资源加载，而隐式加载则是在程序启动时就加载，当调用DLL过多时可能出现启动时间长，由于全程加载DLL，也会出现资源占用的情况，而且其实隐式加载也是采用LoadLibary函数这套机制。</p><h3 id="3-解决名字改编问题"><a href="#3-解决名字改编问题" class="headerlink" title="3 解决名字改编问题"></a>3 解决名字改编问题</h3><p>C++编译器在生成DLL时会对导出进行名字改编，且不同的编译器改编规则不同，因此需要加入限定符<strong>extern “C”</strong>，保证导出函数名称不发生变化</p><pre class=" language-c++"><code class="language-c++">ex:#ifdef DLL_API#else#define DLL_API extern “C” _declspec(dllimport)#endifDLL_API fun1();DLL_API fun2();...</code></pre><p><strong>缺点：</strong> <strong>无法导出类的成员函数</strong>，只能导出全局函数，且函数调用约定改变，仍会改编函数的名字，因此这种情况需要使用<strong>添加模块定义文件（.def）</strong></p><pre class=" language-c++"><code class="language-c++">LIBRARY DllName(必须和生成的动态链接库名字匹配)EXPORTSfunName1(只需要函数名)funName2...</code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 动态链接库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UTF-8转宽字符</title>
      <link href="2020/11/17/utf-8-zhuan-kuan-zi-fu/"/>
      <url>2020/11/17/utf-8-zhuan-kuan-zi-fu/</url>
      
        <content type="html"><![CDATA[<p>写这个主要是记录一下两个函数功能、</p><p>事情起源于对某答题系统实现自动获取答案功能、</p><p>该答题系统采用TCP协议进行数据传输，通过wireshark抓包分析得出该答题系统的答案校验功能在客户端运行而非服务器端（也许是出于服务器无法承受多用户同时提交答案校验），服务器向客户端传输的TCP包中同时包含题目和答案，分别在对应的标签中，于是为自动获取答案创造了有利条件、</p><p>数据获取可以通过winpcap开发包简单方便实现，于是利用该库写了一个dll（TCPCapture.dll）实现对指定服务器地址的指定协议数据包进行无间断抓取，提供给程序抓包线程调用。</p><p>组报和报文解析单独开辟线程处理。提取答案时，由于字节流采用UTF-8编码，如何将中文显示到MFC对话框内，花费了一些时间研究。其实如果你是使用Python编程，会简单很多，Python支持指定编码方式解析字节流，提取标签内容可以采用正则表达式或者find函数对关键词搜索即可，但为了追求原汁原味和尽可能减少程序依赖库（其实是因为用惯了C++），我选择了自己编码解析（自己摧残自己）。</p><img src="/2020/11/17/utf-8-zhuan-kuan-zi-fu/程序组成框图.bmp" alt="程序组成框图" style="zoom:80%;"><p>因为之前对字符编码方式不甚了解，所以在答案显示这一步花费了不少时间。BD了一圈，CSDN也晃悠了一圈，试验了好几段代码均以失败告终，最后还是找到了一段代码，避免以后走弯路，所以在这里写下来。</p><pre><code>CString XXDlg::UTF8ToUnicode(char* UTF8){    DWORD dwUnicodeLen;             //  转换后Unicode的长度    TCHAR* pwText;                  //  保存Unicode的指针    CString strUnicode              //  函数返回值    //  获取转换后的长度并分配内存    dwUnicodeLen = MultiByteToWideChar(CP_UTF8, 0, UTF8, -1, NULL, 0);    pwText = new TCHAR[dwUnicodeLen];    if(!pwText)    {        return (_T("失败")）；    }    //  转换为Unicode    MultiByteToWideChar(CP_UTF8, 0, UTF8, -1, pwText, dwUnicodeLen);    //  转换为CString    strUnicode.Format(_T("%s"), pwText);    //  清除内存    delete[] pwText;    //  返回值    return strUnicode;}</code></pre><p>回过头来看其实并没有什么技术含量（所以总结下来教训就是：知识和经验不够带来的就是时间代价），主要就是用 MultiByteToWideChar()这个函数按指定编码规则（CP_UTF8说明这里是按UTF-8解码）实现多字节向宽字符转换。</p><p>最后出于功能完整性以及用户体验性考虑（其实是懒）决定将答案自动复制到剪贴板，这样使用过程中就只需要粘贴了，也附上代码。</p><pre><code>void XXDlg::CopyToClipBoard(CString str){    if (this-&gt;OpenClipboard())    {        LPSTR pBuf = NULL;        LPCTSTR pSrc = (LPCTSTR) str;        size_t nLen = (_tcslen(pSrc)) + 1) * sizeof(TCHAR);        ::EmptyClipboard();        pBuf = (LPSTR) ::GlobalAlloc(GMEM_DDESHARE, nLen);        memcpy(pBuf, pSrc, nLen);        ::SetClipboardData(CF_UNICODETEXT, pBuf);        ::CloseClipboard();    }    else    {    GetDlgItem(IDC_TMDA)-&gt;SetWindowTextW(_T("复制失败"))；}}</code></pre><p>最近发现自己以前花时间搜索实现的代码，要么不知道放哪去了，要么不记得怎么使用了，所以决定简单记录一下用过的一些代码片段，方便以后需要的时候不用再花费时间去检索了。</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
