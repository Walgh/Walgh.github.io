<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设备基本管理</title>
      <link href="posts/8ea9b4cd/"/>
      <url>posts/8ea9b4cd/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-路由器组件"><a href="#1-1-路由器组件" class="headerlink" title="1.1 路由器组件"></a>1.1 路由器组件</h2><img src="/posts/8ea9b4cd/路由器组件.PNG" alt="路由器组件" style="zoom:60%;"><h2 id="1-2-路由器的组成及功能"><a href="#1-2-路由器的组成及功能" class="headerlink" title="1.2 路由器的组成及功能"></a>1.2 路由器的组成及功能</h2><img src="/posts/8ea9b4cd/路由器组成及功能.PNG" alt="路由器组成及功能" style="zoom:60%;"><h2 id="1-3-Cisco路由器的启动步骤"><a href="#1-3-Cisco路由器的启动步骤" class="headerlink" title="1.3 Cisco路由器的启动步骤"></a>1.3 Cisco路由器的启动步骤</h2><h2 id="1-4-Cisco设备管理"><a href="#1-4-Cisco设备管理" class="headerlink" title="1.4 Cisco设备管理"></a>1.4 Cisco设备管理</h2><p>通过多种方法访问CLI环境，常用的方法有：</p><blockquote><p>—控制台</p></blockquote><blockquote><p>—Telnet或SSH</p></blockquote><blockquote><p>—辅助端口</p></blockquote><h2 id="1-5-机柜"><a href="#1-5-机柜" class="headerlink" title="1.5 机柜"></a>1.5 机柜</h2><blockquote><p>网络机柜标准为42U</p></blockquote><blockquote><p>1U= 4.445cm</p></blockquote><h2 id="1-6-Cisco-IOS软件映像文件命名规则"><a href="#1-6-Cisco-IOS软件映像文件命名规则" class="headerlink" title="1.6 Cisco IOS软件映像文件命名规则"></a>1.6 Cisco IOS软件映像文件命名规则</h2><p><font color="black">c3660</font>-<font color="red">jk9o3s</font>-<font color="blue">mz</font>. <font color="#00ffff">124-15.T5</font></p><blockquote><p><font color="black">(1) 硬件平台</font></p></blockquote><blockquote><p><font color="red">(2) 特性集</font></p></blockquote><blockquote><p><font color="blue">(3) 运行方式</font></p></blockquote><blockquote><p><font color="#00ffff">(4) 版本号</font></p></blockquote><h2 id="1-7-产品包"><a href="#1-7-产品包" class="headerlink" title="1.7 产品包"></a>1.7 产品包</h2><img src="/posts/8ea9b4cd/产品包.PNG" alt="产品包" style="zoom:60%;"><h1 id="2-Cisco-IOS配置管理"><a href="#2-Cisco-IOS配置管理" class="headerlink" title="2 Cisco IOS配置管理"></a>2 Cisco IOS配置管理</h1><h2 id="2-1-show命令"><a href="#2-1-show命令" class="headerlink" title="2.1 show命令"></a>2.1 show命令</h2><blockquote><p>最基本的检查命令<br>可使用show命令来获得可在当前上下文或模式下使用的命令的列表</p></blockquote><img src="/posts/8ea9b4cd/show命令.PNG" alt="show命令" style="zoom:60%;"><h2 id="2-2-配置主机名"><a href="#2-2-配置主机名" class="headerlink" title="2.2 配置主机名"></a>2.2 配置主机名</h2><blockquote><p>采用hostname “名字”</p></blockquote><h2 id="2-3-限制设备访问—配置口令和使用标语"><a href="#2-3-限制设备访问—配置口令和使用标语" class="headerlink" title="2.3 限制设备访问—配置口令和使用标语"></a>2.3 限制设备访问—配置口令和使用标语</h2><blockquote><p>使能口令——enable “password”<br>使能加密口令——enable secret “password”<br>控制台口令——line console “编号”，再设置password<br>VTY口令——line vty “编号”，再设置password</p></blockquote><h2 id="2-4-配置接口"><a href="#2-4-配置接口" class="headerlink" title="2.4 配置接口"></a>2.4 配置接口</h2><img src="/posts/8ea9b4cd/配置接口.PNG" alt="配置接口" style="zoom:60%;">]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCNA </tag>
            
            <tag> 网络设备管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+gitee搭建自己的博客以及那些踩过的坑儿</title>
      <link href="posts/295e0edf/"/>
      <url>posts/295e0edf/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP子网规划</title>
      <link href="posts/5ee816e0/"/>
      <url>posts/5ee816e0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-IP地址"><a href="#1-IP地址" class="headerlink" title="1 IP地址"></a>1 IP地址</h1><p>网络层概念<br>主机唯一的标志，保证主机间正常通信<br>IPv4地址由32bit组成</p><h1 id="2-IP地址分类"><a href="#2-IP地址分类" class="headerlink" title="2 IP地址分类"></a>2 IP地址分类</h1><p>IP地址共分A|B|C|D|E5个类别</p><img src="/posts/5ee816e0/IP地址分类.PNG" alt="IP地址分类" style="zoom:60%;"><h2 id="2-1-特殊IPv4地址"><a href="#2-1-特殊IPv4地址" class="headerlink" title="2.1 特殊IPv4地址"></a>2.1 特殊IPv4地址</h2><p>网络地址和广播地址<br>默认路由：0.0.0.0<br>环回地址：127.0.0.0/8 用于测试<br>链路本地地址：169.254.0.0/16 Windows<br>TEST-NET地址：192.0.2.0/24 保留地址</p><h1 id="3-IP地址的组成"><a href="#3-IP地址的组成" class="headerlink" title="3 IP地址的组成"></a>3 IP地址的组成</h1><p>IP地址由两部分组成<br> 网络部分（NETWORK）<br> 主机部分（HOST）</p><img src="/posts/5ee816e0/IP地址组成.PNG" alt="IP地址组成" style="zoom:60%;"><img src="/posts/5ee816e0/IP地址分类2.PNG" alt="IP地址第二分类" style="zoom:60%;"><h1 id="4-子网掩码"><a href="#4-子网掩码" class="headerlink" title="4 子网掩码"></a>4 子网掩码</h1><p>用来确定IP的网络地址<br>32个二进制位<br>IP地址中的网络部分用1表示，主机部分用0表示<br>IP地址和子网掩码作逻辑“与”运算得到网络地址</p><h1 id="5-IPv4网络中的地址类型"><a href="#5-IPv4网络中的地址类型" class="headerlink" title="5 IPv4网络中的地址类型"></a>5 IPv4网络中的地址类型</h1><h2 id="5-1-网络地址"><a href="#5-1-网络地址" class="headerlink" title="5.1 网络地址"></a>5.1 网络地址</h2><p>指代网络的地址，在网络的IPv4地址范围内，最小地址保留为网络地址。此地址的主机部分的每一个主机位为0</p><h2 id="5-2-广播地址"><a href="#5-2-广播地址" class="headerlink" title="5.2 广播地址"></a>5.2 广播地址</h2><p>用于向网络中的所有主机发送数据的特殊地址。广播地址使用该网络范围内的最大地址。即主机部分的各比特位全部为1的地址。</p><h2 id="5-3-主机地址"><a href="#5-3-主机地址" class="headerlink" title="5.3 主机地址"></a>5.3 主机地址</h2><p>分配给网络中终端设备的地址</p><h1 id="6-划分子网"><a href="#6-划分子网" class="headerlink" title="6 划分子网"></a>6 划分子网</h1><p>子网划分：将网络划分为适当大小的多个子网</p><h2 id="6-1-为什么要划分子网？"><a href="#6-1-为什么要划分子网？" class="headerlink" title="6.1 为什么要划分子网？"></a>6.1 为什么要划分子网？</h2><ol><li>提供灵活的编制</li><li>便于管理</li><li>广播抑制<br>“借用”主机位来“制造”新的“网络”（网络位向主机位借位）</li></ol><h2 id="6-2-子网划分原理"><a href="#6-2-子网划分原理" class="headerlink" title="6.2 子网划分原理"></a>6.2 子网划分原理</h2><p>IP地址经过一次子网划分后，被分成3个部分——网络位、子网位和主机位<br>子网数=2^n，其中n为子网部分位数<br>主机数=2^N-2，其中N为主机部分位数</p>]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IP子网规划 </tag>
            
            <tag> CCNA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP-IP协议簇</title>
      <link href="posts/102a7a5d/"/>
      <url>posts/102a7a5d/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常见协议"><a href="#1-常见协议" class="headerlink" title="1 常见协议"></a>1 常见协议</h1><h2 id="1-1-常见协议"><a href="#1-1-常见协议" class="headerlink" title="1.1 常见协议"></a>1.1 常见协议</h2><img src="/posts/102a7a5d/常见协议.PNG" alt="常见协议" style="zoom:60%;"><h2 id="1-2-TCP头部"><a href="#1-2-TCP头部" class="headerlink" title="1.2 TCP头部"></a>1.2 TCP头部</h2><img src="/posts/102a7a5d/TCP头部.PNG" alt="TCP头部" style="zoom:60%;"><h1 id="2-三次握手"><a href="#2-三次握手" class="headerlink" title="2 三次握手"></a>2 三次握手</h1><p>第一次：sender-&gt;reciever  发送SYN=1<br>第二次：reciever-&gt;sender  发送SYN=1 ACK=1<br>第三次：sender-&gt;reciever  发送ACK=1<br>ack = seq+1   小写ack确认序号</p><img src="/posts/102a7a5d/三次握手.PNG" alt="三次握手" style="zoom:60%;"><h1 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3 滑动窗口"></a>3 滑动窗口</h1><p>reciever收到3个包将回传3个确认，sender知晓当前3个窗口空闲，继续发送3个包，避免网络拥堵</p><img src="/posts/102a7a5d/滑动窗口.PNG" alt="滑动窗口" style="zoom:60%;"><h1 id="4-四次挥手"><a href="#4-四次挥手" class="headerlink" title="4 四次挥手"></a>4 四次挥手</h1><p>第一次：sender-&gt;reciever  发送FIN=1<br>第二次：reciever-&gt;sender  发送ACK=1<br>第三次：reciever-&gt;sender  发送FIN=1  因为此时sender虽然发起断开请求，但reciever不一定接收完数据，所以需要等待数据确认后由reciever向sender发送FIN=1<br>第四次：sender-&gt;reciever  发送ACK=1</p><img src="/posts/102a7a5d/四次挥手.PNG" alt="四次挥手" style="zoom:60%;"><h1 id="5-端口号类型"><a href="#5-端口号类型" class="headerlink" title="5 端口号类型"></a>5 端口号类型</h1><img src="/posts/102a7a5d/端口类型.PNG" alt="端口类型" style="zoom:60%;"><h1 id="6-TCP数据段重组"><a href="#6-TCP数据段重组" class="headerlink" title="6 TCP数据段重组"></a>6 TCP数据段重组</h1><p>使用序列号</p><img src="/posts/102a7a5d/TCP数据段重组.PNG" alt="TCP数据段重组" style="zoom:60%;"><h1 id="7-UDP数据段重组"><a href="#7-UDP数据段重组" class="headerlink" title="7 UDP数据段重组"></a>7 UDP数据段重组</h1><img src="/posts/102a7a5d/UDP数据段重组.PNG" alt="UDP数据段重组" style="zoom:60%;"><h1 id="8-IP"><a href="#8-IP" class="headerlink" title="8 IP"></a>8 IP</h1><p>有IPv4(32bit)和IPv6(128bit)<br>TTL值：生命周期，每经过一次路由-1，当TTL为0时丢弃该数据包</p><img src="/posts/102a7a5d/IP报头.PNG" alt="IP报头" style="zoom:60%;"><h2 id="8-1-常见IP协议"><a href="#8-1-常见IP协议" class="headerlink" title="8.1 常见IP协议"></a>8.1 常见IP协议</h2><p>ICMP(网际控制报文协议)：检测网络层的连通性，发送echo request，目标收到后，发送echo reply 常用命令有ping、traceroute</p><img src="/posts/102a7a5d/ICMP.PNG" alt="ICMP" style="zoom:60%;"><p>ARP(地址解析协议)：通过广播查询IP对应的MAC，有代理ARP和反向ARP</p><h1 id="9-双绞线制作"><a href="#9-双绞线制作" class="headerlink" title="9 双绞线制作"></a>9 双绞线制作</h1><img src="/posts/102a7a5d/双绞线线序.PNG" alt="双绞线线序" style="zoom:60%;">]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCNA </tag>
            
            <tag> 网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础</title>
      <link href="posts/91149a63/"/>
      <url>posts/91149a63/</url>
      
        <content type="html"><![CDATA[<h1 id="1-网络基础"><a href="#1-网络基础" class="headerlink" title="1 网络基础"></a>1 网络基础</h1><h2 id="1-1-什么是网络"><a href="#1-1-什么是网络" class="headerlink" title="1.1 什么是网络"></a>1.1 什么是网络</h2><p>将多台计算机及其外部设备通过通信线路连接起来</p><img src="/posts/91149a63/网络.png" alt="什么是网络" style="zoom:60%;"><h2 id="1-2-网络设备"><a href="#1-2-网络设备" class="headerlink" title="1.2 网络设备"></a>1.2 网络设备</h2><img src="/posts/91149a63/网络设备图标.png" alt="网络设备图标" style="zoom:60%;"><h3 id="1-2-1-Hub-集线器"><a href="#1-2-1-Hub-集线器" class="headerlink" title="1.2.1 Hub(集线器)"></a>1.2.1 Hub(集线器)</h3><p>​            优点：便宜<br>​            缺点：共享型，无法满足多人同时访问</p><h3 id="1-2-2-交换机"><a href="#1-2-2-交换机" class="headerlink" title="1.2.2 交换机"></a>1.2.2 交换机</h3><p>​            所有的接口在同一个广播域<br>​            优点：可实现多用户同时访问，支持全双工<br>​            缺点：共享型，无法满足多人同时访问<br>​            作用：终端用户设备的接入\基本的安全功能\广播域的隔离（VLAN） </p><h3 id="1-2-3-路由器"><a href="#1-2-3-路由器" class="headerlink" title="1.2.3 路由器"></a>1.2.3 路由器</h3><p>​            每一个接口是一个独立的广播域<br>​            优点：可搭建大型网络、安全性高<br>​            缺点：接口太少、价格太贵<br>​            作用：路由协议支持\路径选择\数据转发\广域网接入</p><h3 id="1-2-4-TIPS"><a href="#1-2-4-TIPS" class="headerlink" title="1.2.4 TIPS"></a>1.2.4 TIPS</h3><h4 id="传输类型："><a href="#传输类型：" class="headerlink" title="传输类型："></a>传输类型：</h4><p>​            单工(始终只能完成一个方向的数据传输)<br>​            半双工(同一时间只能完成一个方向的数据传输)<br>​            全双工(同一时间可以完成两个方向的数据传输)</p><h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><p>​            广播报文(单IP到所有IP)<br>​            单播报文(单IP到单IP)<br>​            组播报文(单IP到多IP，类似朋友圈的部分可见）</p><h1 id="2-OSI七层模型"><a href="#2-OSI七层模型" class="headerlink" title="2 OSI七层模型"></a>2 OSI七层模型</h1><p>从下至上分别是物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><img src="/posts/91149a63/OSI.png" alt="OSI" style="zoom:60%;"><h2 id="2-1-应用层"><a href="#2-1-应用层" class="headerlink" title="2.1 应用层"></a>2.1 应用层</h2><p>为应用软件提供接口，使应用程序能够使用网络服务<br>    http(80)<br>    https(443)<br>    dns(53)<br>    ftp(20/21)<br>    smtp(25)<br>    pop3(110)<br>    telnet(23)<br>上述数字代表其端口号</p><h2 id="2-2-表示层"><a href="#2-2-表示层" class="headerlink" title="2.2 表示层"></a>2.2 表示层</h2><p>数据的解码和编码 加密和解密 压缩和解压缩</p><h2 id="2-3-会话层"><a href="#2-3-会话层" class="headerlink" title="2.3 会话层"></a>2.3 会话层</h2><p>负责建立、管理和终止表示层实体之间的会话连接</p><h2 id="2-4-传输层-主要为TCP-UDP"><a href="#2-4-传输层-主要为TCP-UDP" class="headerlink" title="2.4 传输层(主要为TCP/UDP)"></a>2.4 传输层(主要为TCP/UDP)</h2><p>负责建立端到端的连接，保证报文在端到端之间的传输</p><h2 id="2-5-网络层"><a href="#2-5-网络层" class="headerlink" title="2.5 网络层"></a>2.5 网络层</h2><p>为网络设备提供逻辑地址<br>    进行路由选择、维护路由表<br>    负责将分组数据从源端传输到目的端<br>    代表：路由器</p><h2 id="2-6-数据链路层-MAC"><a href="#2-6-数据链路层-MAC" class="headerlink" title="2.6 数据链路层(MAC)"></a>2.6 数据链路层(MAC)</h2><p>在不可靠的物理链路上，提供可靠的数据传输服务，把帧从一跳(结点)移动到另一帧（结点）<br>    组帧、物理编址、流量控制、差错控制、接入控制<br>    代表：交换机</p><h2 id="2-7-物理层"><a href="#2-7-物理层" class="headerlink" title="2.7 物理层"></a>2.7 物理层</h2><p>负责把逐个的比特从一跳(结点)移动到另一跳(结点)<br>    代表：集线器</p><h1 id="3-数据的封装与解封装"><a href="#3-数据的封装与解封装" class="headerlink" title="3 数据的封装与解封装"></a>3 数据的封装与解封装</h1><img src="/posts/91149a63/数据封装.PNG" alt="数据封装" style="zoom:60%;"><img src="/posts/91149a63/数据解封装.PNG" alt="数据解封装" style="zoom:60%;"><h1 id="4-DoD-TCP-IP-模型"><a href="#4-DoD-TCP-IP-模型" class="headerlink" title="4 DoD(TCP/IP)模型"></a>4 DoD(TCP/IP)模型</h1><p>从下至上分别是网络访问层、Internet层、传输层、应用层</p><img src="/posts/91149a63/DoD.PNG" alt="DoD" style="zoom:60%;"><h1 id="5-网关"><a href="#5-网关" class="headerlink" title="5 网关"></a>5 网关</h1><p>广播域的进出口</p>]]></content>
      
      
      <categories>
          
          <category> CCNA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCNA </tag>
            
            <tag> 网络基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态链接库</title>
      <link href="posts/29b48e9/"/>
      <url>posts/29b48e9/</url>
      
        <content type="html"><![CDATA[<h1 id="1-DLL的创建"><a href="#1-DLL的创建" class="headerlink" title="1 DLL的创建"></a>1 DLL的创建</h1><h2 id="1-1-函数的导出"><a href="#1-1-函数的导出" class="headerlink" title="1.1 函数的导出"></a>1.1 函数的导出</h2><p>方法1：在导出函数前面添加<strong>标识符</strong>：</p><pre class="line-numbers language-c++"><code class="language-c++">_declspec（dllexport）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法2：将上述指令进行<strong>宏定义</strong></p><pre class="line-numbers language-c++"><code class="language-c++">#define DLL_API _declspec（dllexport）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-2-类的导出"><a href="#1-2-类的导出" class="headerlink" title="1.2 类的导出"></a>1.2 类的导出</h2><p>在类名前加入宏定义 DLL_API</p><pre class="line-numbers language-c++"><code class="language-c++">ex:class DLL_API XXCLASS{}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若只需导出类中的某个函数，则可只在对应函数前加入修饰符、</p><p>调用方法均需要先对类进行实例化，且<strong>导出函数必须是public属性</strong></p><h2 id="1-3-支持MFC的DLL"><a href="#1-3-支持MFC的DLL" class="headerlink" title="1.3 支持MFC的DLL"></a>1.3 支持MFC的DLL</h2><h3 id="1-3-1-动态链接MFC"><a href="#1-3-1-动态链接MFC" class="headerlink" title="1.3.1 动态链接MFC"></a>1.3.1 动态链接MFC</h3><p>发布DLL时需提供MFC动态链接库</p><h3 id="1-3-2-静态链接MFC"><a href="#1-3-2-静态链接MFC" class="headerlink" title="1.3.2 静态链接MFC"></a>1.3.2 静态链接MFC</h3><p>发布时无需提供MFC动态链接库</p><h3 id="1-3-3-MFC扩展DLL"><a href="#1-3-3-MFC扩展DLL" class="headerlink" title="1.3.3 MFC扩展DLL"></a>1.3.3 MFC扩展DLL</h3><p>使用共享的MFC DLL，支持导出MFC类，而两种方式只支持导出自己编写的C++类</p><h1 id="2-DLL的调用"><a href="#2-DLL的调用" class="headerlink" title="2 DLL的调用"></a>2 DLL的调用</h1><h2 id="2-1-隐式加载"><a href="#2-1-隐式加载" class="headerlink" title="2.1 隐式加载"></a>2.1 隐式加载</h2><p><strong>方法1：</strong>使用<strong>extern关键字</strong>对引用函数进行外部声明 </p><p><strong>方法2：</strong>使用标识符——<strong>declspec（dllimport）</strong>对引用函数进行声明</p><p><strong>方法3：</strong>在发布DLL时提供头文件，头文件内包含导出函数、类（<strong>实际应用均应该这样</strong>）</p><pre class="line-numbers language-c++"><code class="language-c++">ex:#ifdef DLL_API#else#define DLL_API _declspec(dllimport)#endifDLL_API fun1();DLL_API fun2();...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-显示加载"><a href="#2-2-显示加载" class="headerlink" title="2.2 显示加载"></a>2.2 显示加载</h2><p>LoadLibary函数</p><p>FreeLibrary函数：释放该DLL</p><h2 id="2-3-隐式和显示的区别"><a href="#2-3-隐式和显示的区别" class="headerlink" title="2.3 隐式和显示的区别"></a>2.3 隐式和显示的区别</h2><p>显示加载时在程序调用时才进行资源加载，而隐式加载则是在程序启动时就加载，当调用DLL过多时可能出现启动时间长，由于全程加载DLL，也会出现资源占用的情况，而且其实隐式加载也是采用LoadLibary函数这套机制。</p><h1 id="3-解决名字改编问题"><a href="#3-解决名字改编问题" class="headerlink" title="3 解决名字改编问题"></a>3 解决名字改编问题</h1><p>C++编译器在生成DLL时会对导出进行名字改编，且不同的编译器改编规则不同，因此需要加入限定符<strong>extern “C”</strong>，保证导出函数名称不发生变化</p><pre class="line-numbers language-c++"><code class="language-c++">ex:#ifdef DLL_API#else#define DLL_API extern “C” _declspec(dllimport)#endifDLL_API fun1();DLL_API fun2();...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>缺点：</strong> <strong>无法导出类的成员函数</strong>，只能导出全局函数，且函数调用约定改变，仍会改编函数的名字，因此这种情况需要使用<strong>添加模块定义文件（.def）</strong></p><pre class="line-numbers language-c++"><code class="language-c++">LIBRARY DllName(必须和生成的动态链接库名字匹配)EXPORTSfunName1(只需要函数名)funName2...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> 动态链接库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UTF-8转宽字符</title>
      <link href="posts/3cfe74b4/"/>
      <url>posts/3cfe74b4/</url>
      
        <content type="html"><![CDATA[<p>写这个主要是记录一下两个函数功能</p><p>事情起源于对某答题系统实现自动获取答案功能</p><p>该答题系统采用TCP协议进行数据传输，通过wireshark抓包分析得出该答题系统的答案校验功能在客户端运行而非服务器端（也许是出于服务器无法承受多用户同时提交答案校验），服务器向客户端传输的TCP包中同时包含题目和答案，分别在对应的标签中，于是为自动获取答案创造了有利条件</p><p>数据获取可以通过winpcap开发包简单方便实现，于是利用该库写了一个dll（TCPCapture.dll）实现对指定服务器地址的指定协议数据包进行无间断抓取，提供给程序抓包线程调用</p><p>组报和报文解析单独开辟线程处理。提取答案时，由于字节流采用UTF-8编码，如何将中文显示到MFC对话框内，花费了一些时间研究。其实如果你是使用Python编程，会简单很多，Python支持指定编码方式解析字节流，提取标签内容可以采用正则表达式或者find函数对关键词搜索即可，但为了追求原汁原味和尽可能减少程序依赖库（其实是因为用惯了C++），我选择了自己编码解析（自己摧残自己）</p><img src="/posts/3cfe74b4/程序组成框图.bmp" alt="程序组成框图" style="zoom:60%;"><p>因为之前对字符编码方式不甚了解，所以在答案显示这一步花费了不少时间。BD了一圈，CSDN也晃悠了一圈，试验了好几段代码均以失败告终，最后还是找到了一段代码，避免以后走弯路，所以在这里写下来</p><pre class="line-numbers language-C++"><code class="language-C++">CString XXDlg::UTF8ToUnicode(char* UTF8){    DWORD dwUnicodeLen;             //  转换后Unicode的长度    TCHAR* pwText;                  //  保存Unicode的指针    CString strUnicode              //  函数返回值    //  获取转换后的长度并分配内存    dwUnicodeLen = MultiByteToWideChar(CP_UTF8, 0, UTF8, -1, NULL, 0);    pwText = new TCHAR[dwUnicodeLen];    if(!pwText)    {        return (_T("失败")）；    }    //  转换为Unicode    MultiByteToWideChar(CP_UTF8, 0, UTF8, -1, pwText, dwUnicodeLen);    //  转换为CString    strUnicode.Format(_T("%s"), pwText);    //  清除内存    delete[] pwText;    //  返回值    return strUnicode;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回过头来看其实并没有什么技术含量（所以总结下来教训就是：知识和经验不够带来的就是时间代价），主要就是用 MultiByteToWideChar()这个函数按指定编码规则（CP_UTF8说明这里是按UTF-8解码）实现多字节向宽字符转换</p><p>最后出于功能完整性以及用户体验性考虑（其实是懒）决定将答案自动复制到剪贴板，这样使用过程中就只需要粘贴了，也附上代码</p><pre class="line-numbers language-C++"><code class="language-C++">void XXDlg::CopyToClipBoard(CString str){    if (this->OpenClipboard())    {        LPSTR pBuf = NULL;        LPCTSTR pSrc = (LPCTSTR) str;        size_t nLen = (_tcslen(pSrc)) + 1) * sizeof(TCHAR);        ::EmptyClipboard();        pBuf = (LPSTR) ::GlobalAlloc(GMEM_DDESHARE, nLen);        memcpy(pBuf, pSrc, nLen);        ::SetClipboardData(CF_UNICODETEXT, pBuf);        ::CloseClipboard();    }    else    {        GetDlgItem(IDC_TMDA)->SetWindowTextW(_T("复制失败"))；    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最近发现自己以前花时间搜索实现的代码，要么不知道放哪去了，要么不记得怎么使用了，所以决定简单记录一下用过的一些代码片段，方便以后需要的时候不用再花费时间去检索了</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符编码 </tag>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
